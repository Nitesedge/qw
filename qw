#!/bin/bash

# global variables
me=`basename $0`
version="0.2"

ap_file="/tmp/qw_ap.conf"
dhcp_file="/tmp/qw_dhcp.conf"
dhcp_pidfile="/tmp/qw_dhcp.pid"
dhclient_pidfile="/tmp/qw_dhclient.pid"
wpa_file="/tmp/qw_wpa.conf"

ssid="quickAP"
wpa2_passphrase="dontKeepThis"



print_usage(){
    echo "$me-$version the quick wireless tool
Usage: $me command

commands:
   ap [ssid]        start configured ap
   connect [ssid]   connect to configured ap
   sniff [channel]  start sniffing in monitor mode
   managed          switch to managed mode
   kill             kill everything and put interface down
   random           set random mac
   permanent        reset permanent mac

one letter abbreviations are allowed (e.g. '$me a')"
}



kill_all(){
    #TODO: distinguish between own and foreign processes
    systemctl stop NetworkManager
    killall -q dnsmasq
    killall -q hostapd
    killall -q wpa_supplicant
    killall -q dhclient
    set_interface_down
}



set_interface_up(){
    ip l s $wlan_iface up
}



set_interface_down(){
    ip l s $wlan_iface down
}



set_managed_mode(){
    set_interface_down
    iw $wlan_iface set type managed
    set_interface_up
}



set_monitor_mode(){
    type airodump-ng >/dev/null 2>&1 || { echo >&2 "Error: airodump-ng is required."; exit 1; }
    set_interface_down
    iw $wlan_iface set type monitor
    set_interface_up
    if [ $arg2 ]
    then
        channel="-c $arg2"
    fi
    airodump-ng $wlan_iface $channel
}



stop_ap(){
    kill `cat $dhcp_pidfile`
    echo $old_forward_value > /proc/sys/net/ipv4/ip_forward
    if [ $out_iface ] && [ $wlan_iface != $out_iface ]
    then
        iptables -t nat -D POSTROUTING -o $out_iface -j MASQUERADE
    fi
    ip a d 10.113.119.1/24 dev $wlan_iface
    rm $ap_file
    rm $dhcp_file
}



start_ap(){
    type hostapd >/dev/null 2>&1 || { echo >&2 "Error: hostapd is required."; exit 1; }
    type dnsmasq >/dev/null 2>&1 || { echo >&2 "Error: dnsmasq is required."; exit 1; }
    type iptables >/dev/null 2>&1 || { echo >&2 "Error: iptables is required."; exit 1; }
    set_managed_mode
    if [ $arg2 ]
    then
        ssid=$arg2
        read -p "Enter passphrase: " wpa2_passphrase
    fi
    cat > $ap_file << AP_CONF
# temporary hostap config file of qw
interface=$wlan_iface
driver=nl80211
ssid=$ssid
channel=1
hw_mode=g
auth_algs=1
wpa=2
wpa_passphrase=$wpa2_passphrase
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP 
AP_CONF
    cat > $dhcp_file << DHCP_CONF
# temporary dnsmasq config file of qw
interface=$wlan_iface
dhcp-range=interface:$wlan_iface,10.113.119.20,10.113.119.60,infinite 
DHCP_CONF


    # find interface of default route
    out_iface=`ip route | grep -e 'default.*via' -e '0.0.0.0.*via' | head -n 1 | cut -d " " -f 5`

    if [ -z "$out_iface" ]
    then
        echo "Warning: no interface for default route found."
    elif [ $wlan_iface = $out_iface ]
    then
        echo "Warning: the default route is using the selected wlan interface."
    fi

    if [ $out_iface ] && [ $wlan_iface != $out_iface ]
    then
        echo 1 > /proc/sys/net/ipv4/ip_forward
        iptables -t nat -A POSTROUTING -o $out_iface -j MASQUERADE
    else
        echo "Warning: forwarding and NAT won't be enabled."
    fi

    ip a a 10.113.119.1/24 dev $wlan_iface

    trap 'stop_ap' SIGINT
    dnsmasq -C $dhcp_file -x $dhcp_pidfile
    hostapd $ap_file
}



disconnect(){
    kill `cat $dhclient_pidfile`
    rm $wpa_file
}



connect_to_ap(){
    type wpa_supplicant >/dev/null 2>&1 || { echo >&2 "Error: wpa_supplicant is required."; exit 1; }
    type dhclient >/dev/null 2>&1 || { echo >&2 "Error: dhclient is required."; exit 1; }
    set_managed_mode
    if [ $arg2 ]
    then
        ssid=$arg2
        read -p "Enter passphrase: " wpa2_passphrase
    fi
    trap 'disconnect' SIGINT
    wpa_passphrase $ssid $wpa2_passphrase > $wpa_file
    dhclient $wlan_iface -pf $dhclient_pidfile &
    wpa_supplicant -i $wlan_iface -c $wpa_file
}



set_random_mac(){
    type macchanger >/dev/null 2>&1 || { echo >&2 "Error: macchanger is required."; exit 1; }
    set_interface_down
    macchanger -r $wlan_iface
}



set_permanent_mac(){
    type macchanger >/dev/null 2>&1 || { echo >&2 "Error: macchanger is required."; exit 1; }
    set_interface_down
    macchanger -p $wlan_iface
}



if [ $# -lt 1 ]
then
    # no command parameter given, print usage and quit
    print_usage
    exit 1
fi

if [ "$EUID" -ne 0 ]
  then echo "Error: $me has to be run as root"
  exit 1
fi

# store ip forwarding settings to reset afterwards
old_forward_value=`cat /proc/sys/net/ipv4/ip_forward`

# find available wlan interfaces and prompt user if multiple are found
wlan_iface=`iw dev | grep Interface | cut -d " " -f 2`
if [ `echo "$wlan_iface" | wc -l` -gt 1 ]
then
    echo "Multiple wlan interfaces found:"
    echo "$wlan_iface" | nl
    read -p "Enter number of interface to use: " index
    wlan_iface=$(echo "$wlan_iface"| sed -n -e ${index}p)
fi

if [ -z $wlan_iface ]
then
    echo "Error: no wlan interface found"
    exit 1
fi

if [ $# -gt 1 ]
then
arg2=$2
fi

type ip >/dev/null 2>&1 || { echo >&2 "Error: ip is required."; exit 1; }
type iw >/dev/null 2>&1 || { echo >&2 "Error: iw is required."; exit 1; }

case $1 in
    "a"|"ap")           start_ap;;
    "c"|"connect")      connect_to_ap;;
    "s"|"sniff")        set_monitor_mode;;
    "m"|"managed")      set_managed_mode;;
    "k"|"kill")         kill_all;;
    "r"|"random")       set_random_mac;;
    "p"|"permanent")    set_permanent_mac;;
    *)                  print_usage;;
esac
exit 0
